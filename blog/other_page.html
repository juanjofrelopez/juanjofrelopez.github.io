<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>JJL Portfolio</title>
    <link rel="stylesheet" href="../style.css" />
    <link rel="icon" href="../favicon.ico" type="image/x-icon" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>

  <body>
    <main>
      <div class="post-body">
        <div>
          <a href="/">
            <h4 class="subcript">Home üè†</h4>
          </a>
          <h1>
            Testing a simple moving average strategy, and having fun with
            optimization
          </h1>
          <h4 class="subcript">June 2024</h4>
        </div>
        <div>
          <p>
            Given a set of stocks with its weekly close prices, and given 3
            moving averages of different sizes (fast, medium and slow), the goal
            is to find the best combination of this parameters that allow a
            stock to accomplish its maximum Compound annual growth rate (CAGR).
          </p>
          <p>The CAGR is a function of the three window sizes:</p>

          <p>$$ CAGR = f(w1,w2,w3) $$</p>
          <p>
            We will also analyze the profitability of the optimal parameters,
            given by:
          </p>
          <p>$$ p=\frac{profitable \space trades}{total \space trades} $$</p>
          <h2>Approach</h2>
          <p>
            The yield function will be maximized according to the cagr
            parameter, then with the optimal set of window lengths, the
            profitability will be calculated.
          </p>
          <h2>Experiment settings</h2>
          <p>
            The stocks that we'll be analyzing are from the US market and also
            few others from the Argentinean market represented as ADR's. We will
            maximize our strategy by using the minimizing capabilities of the
            algorithms of scipy. Remember that maximizing a function is equal to
            maximizing its negative:
          </p>
          <p>$$ max[f(x)] = min[-f(x)] $$</p>
          <h2>Analyzing the convexity of our function</h2>
          <p>
            The real blessing here would be to have a function that is convex.
            This implies that the local minima is the same as the global minima.
            And we want convex functions because they are easy to optimize,
            meaning the minimum value is easy to find.
          </p>
          <div class="images">
            <img src="../static/convex_non_convex.png" alt="me" width="70%" />
          </div>
          <p>
            In our case we do not have a mathematically defined function that we
            can use to calculate the yield based on out parameters, so we'll
            have to do it empirically.
          </p>
          <p>
            Analyzing the convexity of a function empirically can be done by
            examining the second-order conditions numerically. For a function of
            two variables, this involves evaluating the Hessian matrix, which
            contains the second-order partial derivatives.
          </p>
          <p>
            $$ \mathbf{H}_f = \begin{bmatrix} \frac{\partial^2 f}{\partial
            x_1^2} & \frac{\partial^2 f}{\partial x_1 \partial x_2} \\
            \frac{\partial^2 f}{\partial x_2 \partial x_1} & \frac{\partial^2
            f}{\partial x_2^2} \end{bmatrix} $$
          </p>
          <p>
            This can be calculated in a under-performing way by this script:
          </p>

          <pre><code class="lang-py">
def numerical_hessian(f, x, epsilon=1): 
  n = len(x)
  hessian = np.zeros((n, n))
  perturb = np.eye(n) * epsilon 
  for i in range(n):
    for j in range(n): 
      f_x = f(x) 
      f_x_i = f(x + perturb[i]) 
      f_x_j = f(x + perturb[j]) 
      f_x_ij = f(x + perturb[i] + perturb[j]) 
      hessian[i, j] = (f_x_ij - f_x_i - f_x_j + f_x) / (epsilon ** 2) 
  return hessian
            </code></pre>

          <p>
            Where <code>n</code> is a point that has both values for the window
            sizes <code>[w1,w2]</code> The <code>epsilon</code>
            parameter is a small value used to compute the finite differences.
            But in this case window size values can only be integers, so it
            equals to one. I don't really know or have clear how this affects
            this algorithm.
          </p>
          <p>
            After the simulation (testing only with one stock ticker) with
            values for <code>w1</code> from 20 to 35 and <code>w2</code> from 40
            to 60, we get 47 points where the Hessian is positive semi-definite
            and 289 where the Hessian is NOT positive semi-definite.
            <b>So we can conclude that our function is non-convex.</b> This
            means that it has regions where it is convex and regions where it is
            not. Non-convex functions can have multiple local maxima or minima,
            making optimization more challenging. Libraries like
            <a href="https://www.cvxpy.org/" target="_blank">CVXPY</a>
            which has integer programming capabilities, may not be suitable for
            this problem. We now have to consider optimization methods designed
            for non-convex problems.
          </p>

          NASHEEE
        </div>
      </div>
    </main>
  </body>
</html>
